// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: markdown.sql

package db

import (
	"context"
)

const createMarkdown = `-- name: CreateMarkdown :one
INSERT INTO markdowns (
  relative_path,
  user_id,
  repo_id,
  main_content,
  table_content
) VALUES (
  $1, $2, $3,$4,$5
) RETURNING markdown_id, relative_path, user_id, repo_id, main_content, table_content, updated_at, created_at, fts_zh, fts_en
`

type CreateMarkdownParams struct {
	RelativePath string `json:"relative_path"`
	UserID       int64  `json:"user_id"`
	RepoID       int64  `json:"repo_id"`
	MainContent  string `json:"main_content"`
	TableContent string `json:"table_content"`
}

func (q *Queries) CreateMarkdown(ctx context.Context, arg CreateMarkdownParams) (Markdown, error) {
	row := q.db.QueryRow(ctx, createMarkdown,
		arg.RelativePath,
		arg.UserID,
		arg.RepoID,
		arg.MainContent,
		arg.TableContent,
	)
	var i Markdown
	err := row.Scan(
		&i.MarkdownID,
		&i.RelativePath,
		&i.UserID,
		&i.RepoID,
		&i.MainContent,
		&i.TableContent,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.FtsZh,
		&i.FtsEn,
	)
	return i, err
}

const createMarkdownMulti = `-- name: CreateMarkdownMulti :exec
INSERT INTO markdowns  (
  relative_path,
  user_id,
  repo_id,
  main_content,
  table_content
)
SELECT unnest($1::text[]) AS relative_path,
  unnest($2::bigint[]) AS user_id,
  unnest($3::bigint[]) AS repo_id,
  unnest($4::text[]) AS main_content,
  unnest($5::text[]) AS table_content
`

type CreateMarkdownMultiParams struct {
	RelativePath []string `json:"relative_path"`
	UserID       []int64  `json:"user_id"`
	RepoID       []int64  `json:"repo_id"`
	MainContent  []string `json:"main_content"`
	TableContent []string `json:"table_content"`
}

func (q *Queries) CreateMarkdownMulti(ctx context.Context, arg CreateMarkdownMultiParams) error {
	_, err := q.db.Exec(ctx, createMarkdownMulti,
		arg.RelativePath,
		arg.UserID,
		arg.RepoID,
		arg.MainContent,
		arg.TableContent,
	)
	return err
}

const deleteMarkdownMulti = `-- name: DeleteMarkdownMulti :exec
DELETE FROM markdowns
WHERE (relative_path, repo_id) IN (
  SELECT 
    unnest($1::text[]), 
    unnest($2::bigint[])
)
`

type DeleteMarkdownMultiParams struct {
	RelativePath []string `json:"relative_path"`
	RepoID       []int64  `json:"repo_id"`
}

func (q *Queries) DeleteMarkdownMulti(ctx context.Context, arg DeleteMarkdownMultiParams) error {
	_, err := q.db.Exec(ctx, deleteMarkdownMulti, arg.RelativePath, arg.RepoID)
	return err
}

const getMarkdownByID = `-- name: GetMarkdownByID :one
SELECT markdown_id, relative_path, user_id, repo_id, main_content, table_content, updated_at, created_at, fts_zh, fts_en FROM markdowns
WHERE markdown_id = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetMarkdownByID(ctx context.Context, markdownID int64) (Markdown, error) {
	row := q.db.QueryRow(ctx, getMarkdownByID, markdownID)
	var i Markdown
	err := row.Scan(
		&i.MarkdownID,
		&i.RelativePath,
		&i.UserID,
		&i.RepoID,
		&i.MainContent,
		&i.TableContent,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.FtsZh,
		&i.FtsEn,
	)
	return i, err
}

const getMarkdownContent = `-- name: GetMarkdownContent :one
SELECT 
  markdowns.markdown_id, markdowns.relative_path, markdowns.user_id, markdowns.repo_id, markdowns.main_content, markdowns.table_content, markdowns.updated_at, markdowns.created_at, markdowns.fts_zh, markdowns.fts_en
FROM markdowns
WHERE markdowns.relative_path = $1  and markdowns.repo_id = $2
LIMIT 1
`

type GetMarkdownContentParams struct {
	RelativePath string `json:"relative_path"`
	RepoID       int64  `json:"repo_id"`
}

func (q *Queries) GetMarkdownContent(ctx context.Context, arg GetMarkdownContentParams) (Markdown, error) {
	row := q.db.QueryRow(ctx, getMarkdownContent, arg.RelativePath, arg.RepoID)
	var i Markdown
	err := row.Scan(
		&i.MarkdownID,
		&i.RelativePath,
		&i.UserID,
		&i.RepoID,
		&i.MainContent,
		&i.TableContent,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.FtsZh,
		&i.FtsEn,
	)
	return i, err
}

const getMarkdownRepoID = `-- name: GetMarkdownRepoID :one
SELECT 
  markdowns.repo_id
FROM 
  markdowns
WHERE 
  markdown_id = $1
`

func (q *Queries) GetMarkdownRepoID(ctx context.Context, markdownID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getMarkdownRepoID, markdownID)
	var repo_id int64
	err := row.Scan(&repo_id)
	return repo_id, err
}

const queryMarkdown = `-- name: QueryMarkdown :many
select 
  users.username,r.repo_name, markdown_id,relative_path,users.user_id,r.repo_id,main_content,
  ROUND(ts_rank(fts_zh, plainto_tsquery($3))) + ROUND(ts_rank(fts_en, plainto_tsquery($3))) as rank,
  COALESCE(ts_headline(main_content,plainto_tsquery($3),'MaxFragments=10, MaxWords=7, MinWords=3'),'')
from markdowns 
JOIN repos as r on r.repo_id = markdowns.repo_id
JOIN users on users.user_id = r.user_id
where (fts_zh @@ plainto_tsquery($3) OR fts_en @@ plainto_tsquery($3))
  AND (
    ($4::text='admin' AND $5::bool ) OR (
    users.blocked='false' AND (
      r.visibility_level = 'public'
      OR 
      (r.visibility_level = 'signed' AND $5::bool)
      OR
      (r.visibility_level = 'chosen' AND $5::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $6 AND repo_relations.relation_type = 'visi'))
      OR
      ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $6 AND $5::bool)
    )
  )
  )
ORDER BY
  rank DESC
LIMIT $1
OFFSET $2
`

type QueryMarkdownParams struct {
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
	PlaintoTsquery string `json:"plainto_tsquery"`
	Role           string `json:"role"`
	Signed         bool   `json:"signed"`
	CurUserID      int64  `json:"cur_user_id"`
}

type QueryMarkdownRow struct {
	Username     string      `json:"username"`
	RepoName     string      `json:"repo_name"`
	MarkdownID   int64       `json:"markdown_id"`
	RelativePath string      `json:"relative_path"`
	UserID       int64       `json:"user_id"`
	RepoID       int64       `json:"repo_id"`
	MainContent  string      `json:"main_content"`
	Rank         int32       `json:"rank"`
	Coalesce     interface{} `json:"coalesce"`
}

func (q *Queries) QueryMarkdown(ctx context.Context, arg QueryMarkdownParams) ([]QueryMarkdownRow, error) {
	rows, err := q.db.Query(ctx, queryMarkdown,
		arg.Limit,
		arg.Offset,
		arg.PlaintoTsquery,
		arg.Role,
		arg.Signed,
		arg.CurUserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryMarkdownRow{}
	for rows.Next() {
		var i QueryMarkdownRow
		if err := rows.Scan(
			&i.Username,
			&i.RepoName,
			&i.MarkdownID,
			&i.RelativePath,
			&i.UserID,
			&i.RepoID,
			&i.MainContent,
			&i.Rank,
			&i.Coalesce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryRepoMarkdown = `-- name: QueryRepoMarkdown :many
select 
  users.username,r.repo_name, markdown_id,relative_path,users.user_id,r.repo_id,main_content,
  ROUND(ts_rank(fts_zh, plainto_tsquery($4))) + ROUND(ts_rank(fts_en, plainto_tsquery($4))) as rank,
  COALESCE(ts_headline(main_content,plainto_tsquery($4),'MaxFragments=10, MaxWords=7, MinWords=3'),'')
from markdowns 
JOIN repos as r on r.repo_id = markdowns.repo_id
JOIN users on users.user_id = r.user_id
where users.user_id = $3 and r.repo_id = $5  and (fts_zh @@ plainto_tsquery($4) OR fts_en @@ plainto_tsquery($4))
ORDER BY
  rank DESC
LIMIT $1
OFFSET $2
`

type QueryRepoMarkdownParams struct {
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
	UserID         int64  `json:"user_id"`
	PlaintoTsquery string `json:"plainto_tsquery"`
	RepoID         int64  `json:"repo_id"`
}

type QueryRepoMarkdownRow struct {
	Username     string      `json:"username"`
	RepoName     string      `json:"repo_name"`
	MarkdownID   int64       `json:"markdown_id"`
	RelativePath string      `json:"relative_path"`
	UserID       int64       `json:"user_id"`
	RepoID       int64       `json:"repo_id"`
	MainContent  string      `json:"main_content"`
	Rank         int32       `json:"rank"`
	Coalesce     interface{} `json:"coalesce"`
}

func (q *Queries) QueryRepoMarkdown(ctx context.Context, arg QueryRepoMarkdownParams) ([]QueryRepoMarkdownRow, error) {
	rows, err := q.db.Query(ctx, queryRepoMarkdown,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.PlaintoTsquery,
		arg.RepoID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryRepoMarkdownRow{}
	for rows.Next() {
		var i QueryRepoMarkdownRow
		if err := rows.Scan(
			&i.Username,
			&i.RepoName,
			&i.MarkdownID,
			&i.RelativePath,
			&i.UserID,
			&i.RepoID,
			&i.MainContent,
			&i.Rank,
			&i.Coalesce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryUserMarkdown = `-- name: QueryUserMarkdown :many
select 
  users.username,r.repo_name, markdown_id,relative_path,users.user_id,r.repo_id,main_content,
  ROUND(ts_rank(fts_zh, plainto_tsquery($4))) + ROUND(ts_rank(fts_en, plainto_tsquery($4))) as rank,
  COALESCE(ts_headline(main_content,plainto_tsquery($4),'MaxFragments=10, MaxWords=7, MinWords=3'),'')
from markdowns 
JOIN repos as r on r.repo_id = markdowns.repo_id
JOIN users on users.user_id = r.user_id
where users.user_id = $3  and (fts_zh @@ plainto_tsquery($4) OR fts_en @@ plainto_tsquery($4))
  AND (
    ($5::text='admin' AND $6::bool ) OR (
    users.blocked='false' AND (
      r.visibility_level = 'public'
      OR 
      (r.visibility_level = 'signed' AND $6::bool)
      OR
      (r.visibility_level = 'chosen' AND $6::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $7 AND repo_relations.relation_type = 'visi'))
      OR
      ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $7 AND $6::bool)
    )
  )
  )
ORDER BY
  rank DESC
LIMIT $1
OFFSET $2
`

type QueryUserMarkdownParams struct {
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
	UserID         int64  `json:"user_id"`
	PlaintoTsquery string `json:"plainto_tsquery"`
	Role           string `json:"role"`
	Signed         bool   `json:"signed"`
	CurUserID      int64  `json:"cur_user_id"`
}

type QueryUserMarkdownRow struct {
	Username     string      `json:"username"`
	RepoName     string      `json:"repo_name"`
	MarkdownID   int64       `json:"markdown_id"`
	RelativePath string      `json:"relative_path"`
	UserID       int64       `json:"user_id"`
	RepoID       int64       `json:"repo_id"`
	MainContent  string      `json:"main_content"`
	Rank         int32       `json:"rank"`
	Coalesce     interface{} `json:"coalesce"`
}

func (q *Queries) QueryUserMarkdown(ctx context.Context, arg QueryUserMarkdownParams) ([]QueryUserMarkdownRow, error) {
	rows, err := q.db.Query(ctx, queryUserMarkdown,
		arg.Limit,
		arg.Offset,
		arg.UserID,
		arg.PlaintoTsquery,
		arg.Role,
		arg.Signed,
		arg.CurUserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryUserMarkdownRow{}
	for rows.Next() {
		var i QueryUserMarkdownRow
		if err := rows.Scan(
			&i.Username,
			&i.RepoName,
			&i.MarkdownID,
			&i.RelativePath,
			&i.UserID,
			&i.RepoID,
			&i.MainContent,
			&i.Rank,
			&i.Coalesce,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMarkdownMulti = `-- name: UpdateMarkdownMulti :exec
UPDATE markdowns AS m
SET main_content=tmp.main_content,table_content=tmp.table_content,relative_path=new_relative_path,updated_at=now()
FROM (
  SELECT 
  unnest($1::text[]) AS relative_path,
  unnest($2::text[]) AS new_relative_path,
  unnest($3::text[]) AS main_content,
  unnest($4::text[]) AS table_content,
  unnest($5::bigint[]) AS repo_id
) AS tmp
WHERE m.relative_path = tmp.relative_path and m.repo_id=tmp.repo_id
`

type UpdateMarkdownMultiParams struct {
	RelativePath    []string `json:"relative_path"`
	NewRelativePath []string `json:"new_relative_path"`
	MainContent     []string `json:"main_content"`
	TableContent    []string `json:"table_content"`
	RepoID          []int64  `json:"repo_id"`
}

func (q *Queries) UpdateMarkdownMulti(ctx context.Context, arg UpdateMarkdownMultiParams) error {
	_, err := q.db.Exec(ctx, updateMarkdownMulti,
		arg.RelativePath,
		arg.NewRelativePath,
		arg.MainContent,
		arg.TableContent,
		arg.RepoID,
	)
	return err
}

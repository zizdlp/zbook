// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: comment.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComment = `-- name: CreateComment :one
INSERT INTO comments (
  user_id,
  repo_id,
  markdown_id,
  parent_id, 
  root_id,
  comment_content
) VALUES ($1,$2,$3,$4,$5,$6)
RETURNING comment_id, repo_id, markdown_id, parent_id, root_id, user_id, blocked, comment_content, created_at, fts_comment_zh, fts_comment_en
`

type CreateCommentParams struct {
	UserID         int64       `json:"user_id"`
	RepoID         int64       `json:"repo_id"`
	MarkdownID     int64       `json:"markdown_id"`
	ParentID       pgtype.Int8 `json:"parent_id"`
	RootID         pgtype.Int8 `json:"root_id"`
	CommentContent string      `json:"comment_content"`
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRow(ctx, createComment,
		arg.UserID,
		arg.RepoID,
		arg.MarkdownID,
		arg.ParentID,
		arg.RootID,
		arg.CommentContent,
	)
	var i Comment
	err := row.Scan(
		&i.CommentID,
		&i.RepoID,
		&i.MarkdownID,
		&i.ParentID,
		&i.RootID,
		&i.UserID,
		&i.Blocked,
		&i.CommentContent,
		&i.CreatedAt,
		&i.FtsCommentZh,
		&i.FtsCommentEn,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comments
WHERE comment_id = $1
`

func (q *Queries) DeleteComment(ctx context.Context, commentID int64) error {
	_, err := q.db.Exec(ctx, deleteComment, commentID)
	return err
}

const getCommentBasicInfo = `-- name: GetCommentBasicInfo :one
SELECT comments.comment_id,comments.markdown_id,comments.user_id,comments.parent_id,comments.comment_content,comments.created_at,comments.root_id
FROM comments
WHERE comments.comment_id = $1
LIMIT 1
FOR NO KEY UPDATE
`

type GetCommentBasicInfoRow struct {
	CommentID      int64       `json:"comment_id"`
	MarkdownID     int64       `json:"markdown_id"`
	UserID         int64       `json:"user_id"`
	ParentID       pgtype.Int8 `json:"parent_id"`
	CommentContent string      `json:"comment_content"`
	CreatedAt      time.Time   `json:"created_at"`
	RootID         pgtype.Int8 `json:"root_id"`
}

func (q *Queries) GetCommentBasicInfo(ctx context.Context, commentID int64) (GetCommentBasicInfoRow, error) {
	row := q.db.QueryRow(ctx, getCommentBasicInfo, commentID)
	var i GetCommentBasicInfoRow
	err := row.Scan(
		&i.CommentID,
		&i.MarkdownID,
		&i.UserID,
		&i.ParentID,
		&i.CommentContent,
		&i.CreatedAt,
		&i.RootID,
	)
	return i, err
}

const getCommentDetail = `-- name: GetCommentDetail :one
SELECT comments.comment_id, comments.repo_id, comments.markdown_id, comments.parent_id, comments.root_id, comments.user_id, comments.blocked, comments.comment_content, comments.created_at, comments.fts_comment_zh, comments.fts_comment_en,
  users.username,users.email,users.motto,users.created_at as user_created_at,
  COUNT(DISTINCT CASE WHEN comment_relations.relation_type = 'like' THEN comment_relations.relation_id END)  AS like_count,
  (SELECT COUNT(*) FROM comments c2 WHERE c2.root_id = comments.comment_id) AS reply_count,
  EXISTS(SELECT 1 FROM comment_relations WHERE comment_relations.comment_id = comments.comment_id  and comment_relations.relation_type = 'like' and comment_relations.user_id = $2 ) as is_liked,
  EXISTS(SELECT 1 FROM comment_relations WHERE comment_relations.comment_id = comments.comment_id  and comment_relations.relation_type = 'dislike' and comment_relations.user_id = $2 ) as is_disliked,
  EXISTS(SELECT 1 FROM comment_relations WHERE comment_relations.comment_id = comments.comment_id  and comment_relations.relation_type = 'share' and comment_relations.user_id = $2 ) as is_shared,
  EXISTS(SELECT 1 FROM comment_reports WHERE comment_reports.comment_id = comments.comment_id and comment_reports.user_id = $2 ) as is_reported
FROM comments
LEFT JOIN comment_relations ON comments.comment_id = comment_relations.comment_id
JOIN users ON comments.user_id = users.user_id
WHERE comments.comment_id = $1
GROUP BY comments.comment_id,users.user_id
LIMIT 1
`

type GetCommentDetailParams struct {
	CommentID int64 `json:"comment_id"`
	UserID    int64 `json:"user_id"`
}

type GetCommentDetailRow struct {
	CommentID      int64       `json:"comment_id"`
	RepoID         int64       `json:"repo_id"`
	MarkdownID     int64       `json:"markdown_id"`
	ParentID       pgtype.Int8 `json:"parent_id"`
	RootID         pgtype.Int8 `json:"root_id"`
	UserID         int64       `json:"user_id"`
	Blocked        bool        `json:"blocked"`
	CommentContent string      `json:"comment_content"`
	CreatedAt      time.Time   `json:"created_at"`
	FtsCommentZh   string      `json:"fts_comment_zh"`
	FtsCommentEn   string      `json:"fts_comment_en"`
	Username       string      `json:"username"`
	Email          string      `json:"email"`
	Motto          string      `json:"motto"`
	UserCreatedAt  time.Time   `json:"user_created_at"`
	LikeCount      int64       `json:"like_count"`
	ReplyCount     int64       `json:"reply_count"`
	IsLiked        bool        `json:"is_liked"`
	IsDisliked     bool        `json:"is_disliked"`
	IsShared       bool        `json:"is_shared"`
	IsReported     bool        `json:"is_reported"`
}

func (q *Queries) GetCommentDetail(ctx context.Context, arg GetCommentDetailParams) (GetCommentDetailRow, error) {
	row := q.db.QueryRow(ctx, getCommentDetail, arg.CommentID, arg.UserID)
	var i GetCommentDetailRow
	err := row.Scan(
		&i.CommentID,
		&i.RepoID,
		&i.MarkdownID,
		&i.ParentID,
		&i.RootID,
		&i.UserID,
		&i.Blocked,
		&i.CommentContent,
		&i.CreatedAt,
		&i.FtsCommentZh,
		&i.FtsCommentEn,
		&i.Username,
		&i.Email,
		&i.Motto,
		&i.UserCreatedAt,
		&i.LikeCount,
		&i.ReplyCount,
		&i.IsLiked,
		&i.IsDisliked,
		&i.IsShared,
		&i.IsReported,
	)
	return i, err
}

const getCommentRepoInfo = `-- name: GetCommentRepoInfo :one
SELECT repos.repo_id, repos.user_id, repos.git_protocol, repos.git_host, repos.git_username, repos.git_repo, repos.git_access_token, repos.repo_name, repos.repo_description, repos.sync_token, repos.visibility_level, repos.commit_id, repos.config, repos.home, repos.theme_sidebar, repos.theme_color, repos.created_at, repos.updated_at, repos.fts_repo_en, repos.fts_repo_zh
FROM markdowns
JOIN comments on markdowns.markdown_id=comments.markdown_id
JOIN repos on markdowns.repo_id = repos.repo_id
WHERE comments.comment_id = $1
LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetCommentRepoInfo(ctx context.Context, commentID int64) (Repo, error) {
	row := q.db.QueryRow(ctx, getCommentRepoInfo, commentID)
	var i Repo
	err := row.Scan(
		&i.RepoID,
		&i.UserID,
		&i.GitProtocol,
		&i.GitHost,
		&i.GitUsername,
		&i.GitRepo,
		&i.GitAccessToken,
		&i.RepoName,
		&i.RepoDescription,
		&i.SyncToken,
		&i.VisibilityLevel,
		&i.CommitID,
		&i.Config,
		&i.Home,
		&i.ThemeSidebar,
		&i.ThemeColor,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.FtsRepoEn,
		&i.FtsRepoZh,
	)
	return i, err
}

const getListCommentCount = `-- name: GetListCommentCount :one
SELECT COUNT(*)
FROM comments
JOIN markdowns on markdowns.markdown_id = comments.markdown_id
JOIN repos ON repos.repo_id = markdowns.repo_id
JOIN users ON comments.user_id = users.user_id
JOIN users as mu ON mu.user_id=repos.user_id
`

func (q *Queries) GetListCommentCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getListCommentCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getListCommentLevelOneCount = `-- name: GetListCommentLevelOneCount :one
SELECT Count(*)
FROM comments
LEFT JOIN comment_relations ON comments.comment_id = comment_relations.comment_id
JOIN users ON comments.user_id = users.user_id
WHERE comments.markdown_id = $1 AND comments.parent_id IS NULL
`

func (q *Queries) GetListCommentLevelOneCount(ctx context.Context, markdownID int64) (int64, error) {
	row := q.db.QueryRow(ctx, getListCommentLevelOneCount, markdownID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getListCommentLevelTwoCount = `-- name: GetListCommentLevelTwoCount :one
SELECT Count(*)
FROM comments
LEFT JOIN comments pc ON  comments.parent_id = pc.comment_id
LEFT JOIN users pu ON pu.user_id = pc.user_id
LEFT JOIN comment_relations ON comments.comment_id = comment_relations.comment_id
JOIN users ON comments.user_id = users.user_id
WHERE comments.root_id = $1
`

func (q *Queries) GetListCommentLevelTwoCount(ctx context.Context, rootID pgtype.Int8) (int64, error) {
	row := q.db.QueryRow(ctx, getListCommentLevelTwoCount, rootID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getQueryCommentCount = `-- name: GetQueryCommentCount :one
SELECT COUNT(*)
FROM comments
JOIN markdowns on markdowns.markdown_id = comments.markdown_id
JOIN repos ON repos.repo_id = markdowns.repo_id
JOIN users ON comments.user_id = users.user_id
JOIN users as mu ON mu.user_id=repos.user_id
WHERE (comments.fts_comment_zh @@ plainto_tsquery($1) OR comments.fts_comment_en @@ plainto_tsquery($1))
`

func (q *Queries) GetQueryCommentCount(ctx context.Context, query string) (int64, error) {
	row := q.db.QueryRow(ctx, getQueryCommentCount, query)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listComment = `-- name: ListComment :many
SELECT comments.comment_id, comments.repo_id, comments.markdown_id, comments.parent_id, comments.root_id, comments.user_id, comments.blocked, comments.comment_content, comments.created_at, comments.fts_comment_zh, comments.fts_comment_en,
  users.username,users.email,users.created_at as user_created_at
FROM comments
JOIN markdowns on markdowns.markdown_id = comments.markdown_id
JOIN repos ON repos.repo_id = markdowns.repo_id
JOIN users ON comments.user_id = users.user_id
JOIN users as mu ON mu.user_id=repos.user_id
ORDER BY comments.created_at DESC
LIMIT $1
OFFSET $2
`

type ListCommentParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListCommentRow struct {
	CommentID      int64       `json:"comment_id"`
	RepoID         int64       `json:"repo_id"`
	MarkdownID     int64       `json:"markdown_id"`
	ParentID       pgtype.Int8 `json:"parent_id"`
	RootID         pgtype.Int8 `json:"root_id"`
	UserID         int64       `json:"user_id"`
	Blocked        bool        `json:"blocked"`
	CommentContent string      `json:"comment_content"`
	CreatedAt      time.Time   `json:"created_at"`
	FtsCommentZh   string      `json:"fts_comment_zh"`
	FtsCommentEn   string      `json:"fts_comment_en"`
	Username       string      `json:"username"`
	Email          string      `json:"email"`
	UserCreatedAt  time.Time   `json:"user_created_at"`
}

func (q *Queries) ListComment(ctx context.Context, arg ListCommentParams) ([]ListCommentRow, error) {
	rows, err := q.db.Query(ctx, listComment, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommentRow{}
	for rows.Next() {
		var i ListCommentRow
		if err := rows.Scan(
			&i.CommentID,
			&i.RepoID,
			&i.MarkdownID,
			&i.ParentID,
			&i.RootID,
			&i.UserID,
			&i.Blocked,
			&i.CommentContent,
			&i.CreatedAt,
			&i.FtsCommentZh,
			&i.FtsCommentEn,
			&i.Username,
			&i.Email,
			&i.UserCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommentLevelOne = `-- name: ListCommentLevelOne :many
SELECT comments.comment_id, comments.repo_id, comments.markdown_id, comments.parent_id, comments.root_id, comments.user_id, comments.blocked, comments.comment_content, comments.created_at, comments.fts_comment_zh, comments.fts_comment_en,
  users.username,users.email,users.motto,users.created_at as user_created_at,
  COUNT(DISTINCT CASE WHEN comment_relations.relation_type = 'like' THEN comment_relations.relation_id END)  AS like_count,
  (SELECT COUNT(*) FROM comments c2 WHERE c2.root_id = comments.comment_id) AS reply_count,
  EXISTS(SELECT 1 FROM comment_relations WHERE comment_relations.comment_id = comments.comment_id and comment_relations.relation_type = 'like'  and comment_relations.user_id = $4 ) as is_liked,
  EXISTS(SELECT 1 FROM comment_relations WHERE comment_relations.comment_id = comments.comment_id and comment_relations.relation_type = 'dislike'  and comment_relations.user_id = $4 ) as is_disliked,
  EXISTS(SELECT 1 FROM comment_relations WHERE comment_relations.comment_id = comments.comment_id and comment_relations.relation_type = 'share'  and comment_relations.user_id = $4 ) as is_shared,
  EXISTS(SELECT 1 FROM comment_reports WHERE comment_reports.comment_id = comments.comment_id and comment_reports.user_id = $4 ) as is_reported
FROM comments
LEFT JOIN comment_relations ON comments.comment_id = comment_relations.comment_id
JOIN users ON comments.user_id = users.user_id
WHERE comments.markdown_id = $1 AND comments.parent_id IS NULL
GROUP BY comments.comment_id,users.user_id
ORDER BY comments.created_at DESC
LIMIT $2
OFFSET $3
`

type ListCommentLevelOneParams struct {
	MarkdownID int64 `json:"markdown_id"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
	UserID     int64 `json:"user_id"`
}

type ListCommentLevelOneRow struct {
	CommentID      int64       `json:"comment_id"`
	RepoID         int64       `json:"repo_id"`
	MarkdownID     int64       `json:"markdown_id"`
	ParentID       pgtype.Int8 `json:"parent_id"`
	RootID         pgtype.Int8 `json:"root_id"`
	UserID         int64       `json:"user_id"`
	Blocked        bool        `json:"blocked"`
	CommentContent string      `json:"comment_content"`
	CreatedAt      time.Time   `json:"created_at"`
	FtsCommentZh   string      `json:"fts_comment_zh"`
	FtsCommentEn   string      `json:"fts_comment_en"`
	Username       string      `json:"username"`
	Email          string      `json:"email"`
	Motto          string      `json:"motto"`
	UserCreatedAt  time.Time   `json:"user_created_at"`
	LikeCount      int64       `json:"like_count"`
	ReplyCount     int64       `json:"reply_count"`
	IsLiked        bool        `json:"is_liked"`
	IsDisliked     bool        `json:"is_disliked"`
	IsShared       bool        `json:"is_shared"`
	IsReported     bool        `json:"is_reported"`
}

func (q *Queries) ListCommentLevelOne(ctx context.Context, arg ListCommentLevelOneParams) ([]ListCommentLevelOneRow, error) {
	rows, err := q.db.Query(ctx, listCommentLevelOne,
		arg.MarkdownID,
		arg.Limit,
		arg.Offset,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommentLevelOneRow{}
	for rows.Next() {
		var i ListCommentLevelOneRow
		if err := rows.Scan(
			&i.CommentID,
			&i.RepoID,
			&i.MarkdownID,
			&i.ParentID,
			&i.RootID,
			&i.UserID,
			&i.Blocked,
			&i.CommentContent,
			&i.CreatedAt,
			&i.FtsCommentZh,
			&i.FtsCommentEn,
			&i.Username,
			&i.Email,
			&i.Motto,
			&i.UserCreatedAt,
			&i.LikeCount,
			&i.ReplyCount,
			&i.IsLiked,
			&i.IsDisliked,
			&i.IsShared,
			&i.IsReported,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommentLevelTwo = `-- name: ListCommentLevelTwo :many
SELECT comments.comment_id, comments.repo_id, comments.markdown_id, comments.parent_id, comments.root_id, comments.user_id, comments.blocked, comments.comment_content, comments.created_at, comments.fts_comment_zh, comments.fts_comment_en,
  users.username,users.email,users.motto,users.created_at as user_created_at, pu.username as pusername,
  COUNT(DISTINCT CASE WHEN comment_relations.relation_type = 'like' THEN comment_relations.relation_id END)  AS like_count,
  (SELECT COUNT(*) FROM comments c2 WHERE c2.root_id = comments.comment_id) AS reply_count,
  EXISTS(SELECT 1 FROM comment_relations WHERE comment_relations.comment_id = comments.comment_id  and comment_relations.relation_type = 'like' and comment_relations.user_id = $4 ) as is_liked,
  EXISTS(SELECT 1 FROM comment_relations WHERE comment_relations.comment_id = comments.comment_id  and comment_relations.relation_type = 'dislike' and comment_relations.user_id = $4 ) as is_disliked,
  EXISTS(SELECT 1 FROM comment_relations WHERE comment_relations.comment_id = comments.comment_id  and comment_relations.relation_type = 'share' and comment_relations.user_id = $4 ) as is_shared,
  EXISTS(SELECT 1 FROM comment_reports WHERE comment_reports.comment_id = comments.comment_id and comment_reports.user_id = $4 ) as is_reported
FROM comments
LEFT JOIN comments pc ON  comments.parent_id = pc.comment_id
LEFT JOIN users pu ON pu.user_id = pc.user_id
LEFT JOIN comment_relations ON comments.comment_id = comment_relations.comment_id
JOIN users ON comments.user_id = users.user_id
WHERE comments.root_id = $1
GROUP BY comments.comment_id,users.user_id,pu.username
ORDER BY comments.created_at
LIMIT $2
OFFSET $3
`

type ListCommentLevelTwoParams struct {
	RootID pgtype.Int8 `json:"root_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
	UserID int64       `json:"user_id"`
}

type ListCommentLevelTwoRow struct {
	CommentID      int64       `json:"comment_id"`
	RepoID         int64       `json:"repo_id"`
	MarkdownID     int64       `json:"markdown_id"`
	ParentID       pgtype.Int8 `json:"parent_id"`
	RootID         pgtype.Int8 `json:"root_id"`
	UserID         int64       `json:"user_id"`
	Blocked        bool        `json:"blocked"`
	CommentContent string      `json:"comment_content"`
	CreatedAt      time.Time   `json:"created_at"`
	FtsCommentZh   string      `json:"fts_comment_zh"`
	FtsCommentEn   string      `json:"fts_comment_en"`
	Username       string      `json:"username"`
	Email          string      `json:"email"`
	Motto          string      `json:"motto"`
	UserCreatedAt  time.Time   `json:"user_created_at"`
	Pusername      pgtype.Text `json:"pusername"`
	LikeCount      int64       `json:"like_count"`
	ReplyCount     int64       `json:"reply_count"`
	IsLiked        bool        `json:"is_liked"`
	IsDisliked     bool        `json:"is_disliked"`
	IsShared       bool        `json:"is_shared"`
	IsReported     bool        `json:"is_reported"`
}

func (q *Queries) ListCommentLevelTwo(ctx context.Context, arg ListCommentLevelTwoParams) ([]ListCommentLevelTwoRow, error) {
	rows, err := q.db.Query(ctx, listCommentLevelTwo,
		arg.RootID,
		arg.Limit,
		arg.Offset,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommentLevelTwoRow{}
	for rows.Next() {
		var i ListCommentLevelTwoRow
		if err := rows.Scan(
			&i.CommentID,
			&i.RepoID,
			&i.MarkdownID,
			&i.ParentID,
			&i.RootID,
			&i.UserID,
			&i.Blocked,
			&i.CommentContent,
			&i.CreatedAt,
			&i.FtsCommentZh,
			&i.FtsCommentEn,
			&i.Username,
			&i.Email,
			&i.Motto,
			&i.UserCreatedAt,
			&i.Pusername,
			&i.LikeCount,
			&i.ReplyCount,
			&i.IsLiked,
			&i.IsDisliked,
			&i.IsShared,
			&i.IsReported,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryComment = `-- name: QueryComment :many
SELECT comments.comment_id, comments.repo_id, comments.markdown_id, comments.parent_id, comments.root_id, comments.user_id, comments.blocked, comments.comment_content, comments.created_at, comments.fts_comment_zh, comments.fts_comment_en,
  ROUND(ts_rank(comments.fts_comment_zh, plainto_tsquery($3))) + ROUND(ts_rank(comments.fts_comment_en, plainto_tsquery($3))) as rank,
  users.username,users.email,users.created_at as user_created_at
FROM comments
JOIN markdowns on markdowns.markdown_id = comments.markdown_id
JOIN repos ON repos.repo_id = markdowns.repo_id
JOIN users ON comments.user_id = users.user_id
JOIN users as mu ON mu.user_id=repos.user_id
WHERE (comments.fts_comment_zh @@ plainto_tsquery($3) OR comments.fts_comment_en @@ plainto_tsquery($3))
ORDER BY rank DESC
LIMIT $1
OFFSET $2
`

type QueryCommentParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Query  string `json:"query"`
}

type QueryCommentRow struct {
	CommentID      int64       `json:"comment_id"`
	RepoID         int64       `json:"repo_id"`
	MarkdownID     int64       `json:"markdown_id"`
	ParentID       pgtype.Int8 `json:"parent_id"`
	RootID         pgtype.Int8 `json:"root_id"`
	UserID         int64       `json:"user_id"`
	Blocked        bool        `json:"blocked"`
	CommentContent string      `json:"comment_content"`
	CreatedAt      time.Time   `json:"created_at"`
	FtsCommentZh   string      `json:"fts_comment_zh"`
	FtsCommentEn   string      `json:"fts_comment_en"`
	Rank           int32       `json:"rank"`
	Username       string      `json:"username"`
	Email          string      `json:"email"`
	UserCreatedAt  time.Time   `json:"user_created_at"`
}

func (q *Queries) QueryComment(ctx context.Context, arg QueryCommentParams) ([]QueryCommentRow, error) {
	rows, err := q.db.Query(ctx, queryComment, arg.Limit, arg.Offset, arg.Query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryCommentRow{}
	for rows.Next() {
		var i QueryCommentRow
		if err := rows.Scan(
			&i.CommentID,
			&i.RepoID,
			&i.MarkdownID,
			&i.ParentID,
			&i.RootID,
			&i.UserID,
			&i.Blocked,
			&i.CommentContent,
			&i.CreatedAt,
			&i.FtsCommentZh,
			&i.FtsCommentEn,
			&i.Rank,
			&i.Username,
			&i.Email,
			&i.UserCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

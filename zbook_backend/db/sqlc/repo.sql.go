// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: repo.sql

package db

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRepo = `-- name: CreateRepo :one
INSERT INTO repos (
  user_id,
  git_protocol,
  git_host,
  git_username,
  git_repo,
  git_access_token,
  repo_name,
  theme_sidebar,
  theme_color,
  repo_description,
  sync_token,
  commit_id,
  visibility_level,
  branch
) VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14) 
RETURNING repo_id, user_id, git_protocol, git_host, git_username, git_repo, git_access_token, repo_name, repo_description, sync_token, visibility_level, commit_id, config, home, theme_sidebar, theme_color, created_at, updated_at, branch, fts_repo_en, fts_repo_zh
`

type CreateRepoParams struct {
	UserID          int64       `json:"user_id"`
	GitProtocol     string      `json:"git_protocol"`
	GitHost         string      `json:"git_host"`
	GitUsername     string      `json:"git_username"`
	GitRepo         string      `json:"git_repo"`
	GitAccessToken  pgtype.Text `json:"git_access_token"`
	RepoName        string      `json:"repo_name"`
	ThemeSidebar    string      `json:"theme_sidebar"`
	ThemeColor      string      `json:"theme_color"`
	RepoDescription string      `json:"repo_description"`
	SyncToken       pgtype.Text `json:"sync_token"`
	CommitID        string      `json:"commit_id"`
	VisibilityLevel string      `json:"visibility_level"`
	Branch          string      `json:"branch"`
}

func (q *Queries) CreateRepo(ctx context.Context, arg CreateRepoParams) (Repo, error) {
	row := q.db.QueryRow(ctx, createRepo,
		arg.UserID,
		arg.GitProtocol,
		arg.GitHost,
		arg.GitUsername,
		arg.GitRepo,
		arg.GitAccessToken,
		arg.RepoName,
		arg.ThemeSidebar,
		arg.ThemeColor,
		arg.RepoDescription,
		arg.SyncToken,
		arg.CommitID,
		arg.VisibilityLevel,
		arg.Branch,
	)
	var i Repo
	err := row.Scan(
		&i.RepoID,
		&i.UserID,
		&i.GitProtocol,
		&i.GitHost,
		&i.GitUsername,
		&i.GitRepo,
		&i.GitAccessToken,
		&i.RepoName,
		&i.RepoDescription,
		&i.SyncToken,
		&i.VisibilityLevel,
		&i.CommitID,
		&i.Config,
		&i.Home,
		&i.ThemeSidebar,
		&i.ThemeColor,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Branch,
		&i.FtsRepoEn,
		&i.FtsRepoZh,
	)
	return i, err
}

const deleteRepo = `-- name: DeleteRepo :exec
DELETE FROM repos
WHERE repo_id = $1
`

func (q *Queries) DeleteRepo(ctx context.Context, repoID int64) error {
	_, err := q.db.Exec(ctx, deleteRepo, repoID)
	return err
}

const getListRepoCount = `-- name: GetListRepoCount :one
SELECT
   count(*)
FROM
    repos r
JOIN 
  users u ON u.user_id = r.user_id
WHERE
  ($1::text='admin' AND $2::bool ) OR (
      u.blocked='false' AND (
        r.visibility_level = 'public'
        OR 
        (r.visibility_level = 'signed' AND $2::bool)
        OR
        (r.visibility_level = 'chosen' AND $2::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $3 AND repo_relations.relation_type = 'visi'))
        OR
        ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $3 AND $2::bool)
      )
  )
`

type GetListRepoCountParams struct {
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
	CurUserID int64  `json:"cur_user_id"`
}

func (q *Queries) GetListRepoCount(ctx context.Context, arg GetListRepoCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getListRepoCount, arg.Role, arg.Signed, arg.CurUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getListUserLikeRepoCount = `-- name: GetListUserLikeRepoCount :one
SELECT
 COUNT(*)
FROM
    repos r
JOIN repo_relations AS rr ON r.repo_id = rr.repo_id
JOIN
    users as ur ON ur.user_id=r.user_id
JOIN
    users as uq ON uq.user_id=rr.user_id
WHERE
    uq.user_id = $1 AND rr.relation_type='like' AND ( 
      ($2::text='admin' AND $3::bool ) OR (
        uq.blocked = FALSE AND ur.blocked =FALSE AND 
        (
          (r.visibility_level = 'public' ) 
          OR
          (r.visibility_level = 'signed' AND $3::bool) 
          OR
          (r.visibility_level = 'chosen' AND $3::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $4 AND repo_relations.relation_type = 'visi'))
          OR
          ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $4 AND $3::bool)
        )
      )
    )
`

type GetListUserLikeRepoCountParams struct {
	UserID    int64  `json:"user_id"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
	CurUserID int64  `json:"cur_user_id"`
}

func (q *Queries) GetListUserLikeRepoCount(ctx context.Context, arg GetListUserLikeRepoCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getListUserLikeRepoCount,
		arg.UserID,
		arg.Role,
		arg.Signed,
		arg.CurUserID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getListUserOwnRepoCount = `-- name: GetListUserOwnRepoCount :one
SELECT
    COUNT(*)
FROM
    repos r
JOIN
    users as u ON u.user_id=r.user_id
WHERE
    u.user_id = $1 AND (
      ($2::text='admin' AND $3::bool ) OR (
        u.blocked='false' AND (
          r.visibility_level = 'public'
          OR 
          (r.visibility_level = 'signed' AND $3::bool)
          OR
          (r.visibility_level = 'chosen' AND $3::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $4 AND repo_relations.relation_type = 'visi'))
          OR
          ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $4 AND $3::bool)
        )
      )
    )
`

type GetListUserOwnRepoCountParams struct {
	UserID    int64  `json:"user_id"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
	CurUserID int64  `json:"cur_user_id"`
}

func (q *Queries) GetListUserOwnRepoCount(ctx context.Context, arg GetListUserOwnRepoCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getListUserOwnRepoCount,
		arg.UserID,
		arg.Role,
		arg.Signed,
		arg.CurUserID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getQueryRepoCount = `-- name: GetQueryRepoCount :one
SELECT
   count(*)
FROM
    repos r
JOIN 
  users u ON u.user_id = r.user_id
where (r.fts_repo_en @@ plainto_tsquery($1) OR r.fts_repo_zh @@ plainto_tsquery($1))
  AND (
    ($2::text='admin' AND $3::bool ) OR (
      u.blocked='false' AND (
        r.visibility_level = 'public'
        OR 
        (r.visibility_level = 'signed' AND $3::bool)
        OR
        (r.visibility_level = 'chosen' AND $3::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $4 AND repo_relations.relation_type = 'visi'))
        OR
        ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $4 AND $3::bool)
      )
    )
  )
`

type GetQueryRepoCountParams struct {
	Query     string `json:"query"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
	CurUserID int64  `json:"cur_user_id"`
}

func (q *Queries) GetQueryRepoCount(ctx context.Context, arg GetQueryRepoCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getQueryRepoCount,
		arg.Query,
		arg.Role,
		arg.Signed,
		arg.CurUserID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getQueryUserLikeRepoCount = `-- name: GetQueryUserLikeRepoCount :one
SELECT
  COUNT(*)
FROM
    repos r
JOIN repo_relations AS rr ON r.repo_id = rr.repo_id
JOIN
    users as ur ON ur.user_id=r.user_id
JOIN
    users as uq ON uq.user_id=rr.user_id
WHERE
    (r.fts_repo_en @@ plainto_tsquery($1) OR r.fts_repo_zh @@ plainto_tsquery($1)) AND uq.user_id = $2 AND rr.relation_type='like'  AND ( 
      ($3::text='admin' AND $4::bool ) OR (
        uq.blocked = FALSE AND ur.blocked =FALSE AND 
        (
          (r.visibility_level = 'public' ) 
          OR
          (r.visibility_level = 'signed' AND $4::bool) 
          OR
          (r.visibility_level = 'chosen' AND $4::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $5 AND repo_relations.relation_type = 'visi'))
          OR
          ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $5 AND $4::bool)
        )
      )
    )
`

type GetQueryUserLikeRepoCountParams struct {
	Query     string `json:"query"`
	UserID    int64  `json:"user_id"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
	CurUserID int64  `json:"cur_user_id"`
}

func (q *Queries) GetQueryUserLikeRepoCount(ctx context.Context, arg GetQueryUserLikeRepoCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getQueryUserLikeRepoCount,
		arg.Query,
		arg.UserID,
		arg.Role,
		arg.Signed,
		arg.CurUserID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getQueryUserOwnRepoCount = `-- name: GetQueryUserOwnRepoCount :one
SELECT
  COUNT(*)
FROM
    repos r
JOIN
    users as u ON u.user_id=r.user_id
WHERE
    (r.fts_repo_en @@ plainto_tsquery($1) OR r.fts_repo_zh @@ plainto_tsquery($1)) AND u.user_id = $2 AND (
      ($3::text='admin' AND $4::bool ) OR (
        u.blocked='false' AND (
          r.visibility_level = 'public'
          OR 
          (r.visibility_level = 'signed' AND $4::bool)
          OR
          (r.visibility_level = 'chosen' AND $4::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $5 AND repo_relations.relation_type = 'visi'))
          OR
          ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $5 AND $4::bool)
        )
      )
    )
`

type GetQueryUserOwnRepoCountParams struct {
	Query     string `json:"query"`
	UserID    int64  `json:"user_id"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
	CurUserID int64  `json:"cur_user_id"`
}

func (q *Queries) GetQueryUserOwnRepoCount(ctx context.Context, arg GetQueryUserOwnRepoCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getQueryUserOwnRepoCount,
		arg.Query,
		arg.UserID,
		arg.Role,
		arg.Signed,
		arg.CurUserID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRepo = `-- name: GetRepo :one
SELECT repo_id, user_id, git_protocol, git_host, git_username, git_repo, git_access_token, repo_name, repo_description, sync_token, visibility_level, commit_id, config, home, theme_sidebar, theme_color, created_at, updated_at, branch, fts_repo_en, fts_repo_zh from repos
WHERE repo_id = $1
`

func (q *Queries) GetRepo(ctx context.Context, repoID int64) (Repo, error) {
	row := q.db.QueryRow(ctx, getRepo, repoID)
	var i Repo
	err := row.Scan(
		&i.RepoID,
		&i.UserID,
		&i.GitProtocol,
		&i.GitHost,
		&i.GitUsername,
		&i.GitRepo,
		&i.GitAccessToken,
		&i.RepoName,
		&i.RepoDescription,
		&i.SyncToken,
		&i.VisibilityLevel,
		&i.CommitID,
		&i.Config,
		&i.Home,
		&i.ThemeSidebar,
		&i.ThemeColor,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Branch,
		&i.FtsRepoEn,
		&i.FtsRepoZh,
	)
	return i, err
}

const getRepoBasicInfo = `-- name: GetRepoBasicInfo :one
SELECT repos.repo_id, repos.user_id, repos.git_protocol, repos.git_host, repos.git_username, repos.git_repo, repos.git_access_token, repos.repo_name, repos.repo_description, repos.sync_token, repos.visibility_level, repos.commit_id, repos.config, repos.home, repos.theme_sidebar, repos.theme_color, repos.created_at, repos.updated_at, repos.branch, repos.fts_repo_en, repos.fts_repo_zh,
  users.username, users.email
FROM repos
INNER JOIN users ON repos.user_id = users.user_id
WHERE users.username=$1 AND repos.repo_name=$2
`

type GetRepoBasicInfoParams struct {
	Username string `json:"username"`
	RepoName string `json:"repo_name"`
}

type GetRepoBasicInfoRow struct {
	RepoID          int64       `json:"repo_id"`
	UserID          int64       `json:"user_id"`
	GitProtocol     string      `json:"git_protocol"`
	GitHost         string      `json:"git_host"`
	GitUsername     string      `json:"git_username"`
	GitRepo         string      `json:"git_repo"`
	GitAccessToken  pgtype.Text `json:"git_access_token"`
	RepoName        string      `json:"repo_name"`
	RepoDescription string      `json:"repo_description"`
	SyncToken       pgtype.Text `json:"sync_token"`
	VisibilityLevel string      `json:"visibility_level"`
	CommitID        string      `json:"commit_id"`
	Config          string      `json:"config"`
	Home            string      `json:"home"`
	ThemeSidebar    string      `json:"theme_sidebar"`
	ThemeColor      string      `json:"theme_color"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Branch          string      `json:"branch"`
	FtsRepoEn       string      `json:"fts_repo_en"`
	FtsRepoZh       string      `json:"fts_repo_zh"`
	Username        string      `json:"username"`
	Email           string      `json:"email"`
}

func (q *Queries) GetRepoBasicInfo(ctx context.Context, arg GetRepoBasicInfoParams) (GetRepoBasicInfoRow, error) {
	row := q.db.QueryRow(ctx, getRepoBasicInfo, arg.Username, arg.RepoName)
	var i GetRepoBasicInfoRow
	err := row.Scan(
		&i.RepoID,
		&i.UserID,
		&i.GitProtocol,
		&i.GitHost,
		&i.GitUsername,
		&i.GitRepo,
		&i.GitAccessToken,
		&i.RepoName,
		&i.RepoDescription,
		&i.SyncToken,
		&i.VisibilityLevel,
		&i.CommitID,
		&i.Config,
		&i.Home,
		&i.ThemeSidebar,
		&i.ThemeColor,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Branch,
		&i.FtsRepoEn,
		&i.FtsRepoZh,
		&i.Username,
		&i.Email,
	)
	return i, err
}

const getRepoByRepoName = `-- name: GetRepoByRepoName :one
SELECT repo_id, repos.user_id, git_protocol, git_host, git_username, git_repo, git_access_token, repo_name, repo_description, sync_token, visibility_level, commit_id, config, home, theme_sidebar, theme_color, repos.created_at, repos.updated_at, branch, fts_repo_en, fts_repo_zh, users.user_id, username, email, hashed_password, blocked, verified, motto, user_role, onboarding, users.created_at, users.updated_at, unread_count, unread_count_updated_at, fts_username from repos
JOIN users on users.user_id= repos.user_id
WHERE users.username=$1 AND repos.repo_name=$2
`

type GetRepoByRepoNameParams struct {
	Username string `json:"username"`
	RepoName string `json:"repo_name"`
}

type GetRepoByRepoNameRow struct {
	RepoID               int64       `json:"repo_id"`
	UserID               int64       `json:"user_id"`
	GitProtocol          string      `json:"git_protocol"`
	GitHost              string      `json:"git_host"`
	GitUsername          string      `json:"git_username"`
	GitRepo              string      `json:"git_repo"`
	GitAccessToken       pgtype.Text `json:"git_access_token"`
	RepoName             string      `json:"repo_name"`
	RepoDescription      string      `json:"repo_description"`
	SyncToken            pgtype.Text `json:"sync_token"`
	VisibilityLevel      string      `json:"visibility_level"`
	CommitID             string      `json:"commit_id"`
	Config               string      `json:"config"`
	Home                 string      `json:"home"`
	ThemeSidebar         string      `json:"theme_sidebar"`
	ThemeColor           string      `json:"theme_color"`
	CreatedAt            time.Time   `json:"created_at"`
	UpdatedAt            time.Time   `json:"updated_at"`
	Branch               string      `json:"branch"`
	FtsRepoEn            string      `json:"fts_repo_en"`
	FtsRepoZh            string      `json:"fts_repo_zh"`
	UserID_2             int64       `json:"user_id_2"`
	Username             string      `json:"username"`
	Email                string      `json:"email"`
	HashedPassword       string      `json:"hashed_password"`
	Blocked              bool        `json:"blocked"`
	Verified             bool        `json:"verified"`
	Motto                string      `json:"motto"`
	UserRole             string      `json:"user_role"`
	Onboarding           bool        `json:"onboarding"`
	CreatedAt_2          time.Time   `json:"created_at_2"`
	UpdatedAt_2          time.Time   `json:"updated_at_2"`
	UnreadCount          int32       `json:"unread_count"`
	UnreadCountUpdatedAt time.Time   `json:"unread_count_updated_at"`
	FtsUsername          string      `json:"fts_username"`
}

func (q *Queries) GetRepoByRepoName(ctx context.Context, arg GetRepoByRepoNameParams) (GetRepoByRepoNameRow, error) {
	row := q.db.QueryRow(ctx, getRepoByRepoName, arg.Username, arg.RepoName)
	var i GetRepoByRepoNameRow
	err := row.Scan(
		&i.RepoID,
		&i.UserID,
		&i.GitProtocol,
		&i.GitHost,
		&i.GitUsername,
		&i.GitRepo,
		&i.GitAccessToken,
		&i.RepoName,
		&i.RepoDescription,
		&i.SyncToken,
		&i.VisibilityLevel,
		&i.CommitID,
		&i.Config,
		&i.Home,
		&i.ThemeSidebar,
		&i.ThemeColor,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Branch,
		&i.FtsRepoEn,
		&i.FtsRepoZh,
		&i.UserID_2,
		&i.Username,
		&i.Email,
		&i.HashedPassword,
		&i.Blocked,
		&i.Verified,
		&i.Motto,
		&i.UserRole,
		&i.Onboarding,
		&i.CreatedAt_2,
		&i.UpdatedAt_2,
		&i.UnreadCount,
		&i.UnreadCountUpdatedAt,
		&i.FtsUsername,
	)
	return i, err
}

const getRepoConfig = `-- name: GetRepoConfig :one
SELECT repos.repo_id,config,repos.user_id,visibility_level,repos.theme_sidebar,repos.theme_color,repos.home FROM repos
JOIN users on users.user_id = repos.user_id
WHERE users.username=$1 AND repos.repo_name=$2
`

type GetRepoConfigParams struct {
	Username string `json:"username"`
	RepoName string `json:"repo_name"`
}

type GetRepoConfigRow struct {
	RepoID          int64  `json:"repo_id"`
	Config          string `json:"config"`
	UserID          int64  `json:"user_id"`
	VisibilityLevel string `json:"visibility_level"`
	ThemeSidebar    string `json:"theme_sidebar"`
	ThemeColor      string `json:"theme_color"`
	Home            string `json:"home"`
}

func (q *Queries) GetRepoConfig(ctx context.Context, arg GetRepoConfigParams) (GetRepoConfigRow, error) {
	row := q.db.QueryRow(ctx, getRepoConfig, arg.Username, arg.RepoName)
	var i GetRepoConfigRow
	err := row.Scan(
		&i.RepoID,
		&i.Config,
		&i.UserID,
		&i.VisibilityLevel,
		&i.ThemeSidebar,
		&i.ThemeColor,
		&i.Home,
	)
	return i, err
}

const getRepoHome = `-- name: GetRepoHome :one
SELECT repos.home FROM repos
JOIN users on users.user_id = repos.user_id
WHERE users.username=$1 AND repos.repo_name=$2
`

type GetRepoHomeParams struct {
	Username string `json:"username"`
	RepoName string `json:"repo_name"`
}

func (q *Queries) GetRepoHome(ctx context.Context, arg GetRepoHomeParams) (string, error) {
	row := q.db.QueryRow(ctx, getRepoHome, arg.Username, arg.RepoName)
	var home string
	err := row.Scan(&home)
	return home, err
}

const getRepoID = `-- name: GetRepoID :one
SELECT repos.repo_id 
from repos
JOIN users on users.user_id= repos.user_id
WHERE users.username=$1 AND repos.repo_name=$2
`

type GetRepoIDParams struct {
	Username string `json:"username"`
	RepoName string `json:"repo_name"`
}

func (q *Queries) GetRepoID(ctx context.Context, arg GetRepoIDParams) (int64, error) {
	row := q.db.QueryRow(ctx, getRepoID, arg.Username, arg.RepoName)
	var repo_id int64
	err := row.Scan(&repo_id)
	return repo_id, err
}

const getRepoPermission = `-- name: GetRepoPermission :one
SELECT 
  repos.visibility_level as visibility_level,
  users.user_id,users.blocked as user_blocked,users.username,
  users.user_role as user_role,
  repos.repo_id
FROM 
  repos
INNER JOIN users ON users.user_id = repos.user_id
WHERE 
  repo_id = $1
`

type GetRepoPermissionRow struct {
	VisibilityLevel string `json:"visibility_level"`
	UserID          int64  `json:"user_id"`
	UserBlocked     bool   `json:"user_blocked"`
	Username        string `json:"username"`
	UserRole        string `json:"user_role"`
	RepoID          int64  `json:"repo_id"`
}

func (q *Queries) GetRepoPermission(ctx context.Context, repoID int64) (GetRepoPermissionRow, error) {
	row := q.db.QueryRow(ctx, getRepoPermission, repoID)
	var i GetRepoPermissionRow
	err := row.Scan(
		&i.VisibilityLevel,
		&i.UserID,
		&i.UserBlocked,
		&i.Username,
		&i.UserRole,
		&i.RepoID,
	)
	return i, err
}

const listRepo = `-- name: ListRepo :many
SELECT
   r.repo_id, r.user_id, r.git_protocol, r.git_host, r.git_username, r.git_repo, r.git_access_token, r.repo_name, r.repo_description, r.sync_token, r.visibility_level, r.commit_id, r.config, r.home, r.theme_sidebar, r.theme_color, r.created_at, r.updated_at, r.branch, r.fts_repo_en, r.fts_repo_zh,
   (SELECT COUNT(*) FROM repo_relations WHERE repo_id = r.repo_id and relation_type = 'like') AS like_count,
   u.username,
   EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id  and repo_relations.relation_type = 'like' and repo_relations.user_id = $3 ) as is_liked
FROM
    repos r
JOIN 
  users u ON u.user_id = r.user_id
WHERE
  ($4::text='admin' AND $5::bool ) OR (
    u.blocked='false' AND (
      r.visibility_level = 'public'
      OR 
      (r.visibility_level = 'signed' AND $5::bool)
      OR
      (r.visibility_level = 'chosen' AND $5::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $3 AND repo_relations.relation_type = 'visi'))
      OR
      ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $3 AND $5::bool)
    )
  )
    
ORDER BY r.created_at DESC
LIMIT $1
OFFSET $2
`

type ListRepoParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	CurUserID int64  `json:"cur_user_id"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
}

type ListRepoRow struct {
	RepoID          int64       `json:"repo_id"`
	UserID          int64       `json:"user_id"`
	GitProtocol     string      `json:"git_protocol"`
	GitHost         string      `json:"git_host"`
	GitUsername     string      `json:"git_username"`
	GitRepo         string      `json:"git_repo"`
	GitAccessToken  pgtype.Text `json:"git_access_token"`
	RepoName        string      `json:"repo_name"`
	RepoDescription string      `json:"repo_description"`
	SyncToken       pgtype.Text `json:"sync_token"`
	VisibilityLevel string      `json:"visibility_level"`
	CommitID        string      `json:"commit_id"`
	Config          string      `json:"config"`
	Home            string      `json:"home"`
	ThemeSidebar    string      `json:"theme_sidebar"`
	ThemeColor      string      `json:"theme_color"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Branch          string      `json:"branch"`
	FtsRepoEn       string      `json:"fts_repo_en"`
	FtsRepoZh       string      `json:"fts_repo_zh"`
	LikeCount       int64       `json:"like_count"`
	Username        string      `json:"username"`
	IsLiked         bool        `json:"is_liked"`
}

func (q *Queries) ListRepo(ctx context.Context, arg ListRepoParams) ([]ListRepoRow, error) {
	rows, err := q.db.Query(ctx, listRepo,
		arg.Limit,
		arg.Offset,
		arg.CurUserID,
		arg.Role,
		arg.Signed,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRepoRow{}
	for rows.Next() {
		var i ListRepoRow
		if err := rows.Scan(
			&i.RepoID,
			&i.UserID,
			&i.GitProtocol,
			&i.GitHost,
			&i.GitUsername,
			&i.GitRepo,
			&i.GitAccessToken,
			&i.RepoName,
			&i.RepoDescription,
			&i.SyncToken,
			&i.VisibilityLevel,
			&i.CommitID,
			&i.Config,
			&i.Home,
			&i.ThemeSidebar,
			&i.ThemeColor,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Branch,
			&i.FtsRepoEn,
			&i.FtsRepoZh,
			&i.LikeCount,
			&i.Username,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserLikeRepo = `-- name: ListUserLikeRepo :many
SELECT
   r.repo_id, r.user_id, r.git_protocol, r.git_host, r.git_username, r.git_repo, r.git_access_token, r.repo_name, r.repo_description, r.sync_token, r.visibility_level, r.commit_id, r.config, r.home, r.theme_sidebar, r.theme_color, r.created_at, r.updated_at, r.branch, r.fts_repo_en, r.fts_repo_zh,ur.username,
  (SELECT COUNT(*) FROM repo_relations WHERE repo_id = r.repo_id and relation_type = 'like') AS like_count,
  EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id  and repo_relations.relation_type = 'like' and repo_relations.user_id = $3 ) as is_liked
FROM
    repos r
JOIN 
    repo_relations AS rr ON r.repo_id = rr.repo_id
JOIN
    users as ur ON ur.user_id=r.user_id -- query user likes repo owner
JOIN
    users as uq ON uq.user_id=rr.user_id -- query user
WHERE
    uq.user_id = $4 AND rr.relation_type='like' AND ( 
      ($5::text='admin' AND $6::bool ) OR (
        uq.blocked = FALSE AND ur.blocked =FALSE AND 
        (
          (r.visibility_level = 'public' ) 
          OR
          (r.visibility_level = 'signed' AND $6::bool) 
          OR
          (r.visibility_level = 'chosen' AND $6::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $3 AND repo_relations.relation_type = 'visi'))
          OR
          ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $3 AND $6::bool)
        )
      )
    )
ORDER BY r.created_at DESC
LIMIT $1
OFFSET $2
`

type ListUserLikeRepoParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	CurUserID int64  `json:"cur_user_id"`
	UserID    int64  `json:"user_id"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
}

type ListUserLikeRepoRow struct {
	RepoID          int64       `json:"repo_id"`
	UserID          int64       `json:"user_id"`
	GitProtocol     string      `json:"git_protocol"`
	GitHost         string      `json:"git_host"`
	GitUsername     string      `json:"git_username"`
	GitRepo         string      `json:"git_repo"`
	GitAccessToken  pgtype.Text `json:"git_access_token"`
	RepoName        string      `json:"repo_name"`
	RepoDescription string      `json:"repo_description"`
	SyncToken       pgtype.Text `json:"sync_token"`
	VisibilityLevel string      `json:"visibility_level"`
	CommitID        string      `json:"commit_id"`
	Config          string      `json:"config"`
	Home            string      `json:"home"`
	ThemeSidebar    string      `json:"theme_sidebar"`
	ThemeColor      string      `json:"theme_color"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Branch          string      `json:"branch"`
	FtsRepoEn       string      `json:"fts_repo_en"`
	FtsRepoZh       string      `json:"fts_repo_zh"`
	Username        string      `json:"username"`
	LikeCount       int64       `json:"like_count"`
	IsLiked         bool        `json:"is_liked"`
}

func (q *Queries) ListUserLikeRepo(ctx context.Context, arg ListUserLikeRepoParams) ([]ListUserLikeRepoRow, error) {
	rows, err := q.db.Query(ctx, listUserLikeRepo,
		arg.Limit,
		arg.Offset,
		arg.CurUserID,
		arg.UserID,
		arg.Role,
		arg.Signed,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserLikeRepoRow{}
	for rows.Next() {
		var i ListUserLikeRepoRow
		if err := rows.Scan(
			&i.RepoID,
			&i.UserID,
			&i.GitProtocol,
			&i.GitHost,
			&i.GitUsername,
			&i.GitRepo,
			&i.GitAccessToken,
			&i.RepoName,
			&i.RepoDescription,
			&i.SyncToken,
			&i.VisibilityLevel,
			&i.CommitID,
			&i.Config,
			&i.Home,
			&i.ThemeSidebar,
			&i.ThemeColor,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Branch,
			&i.FtsRepoEn,
			&i.FtsRepoZh,
			&i.Username,
			&i.LikeCount,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOwnRepo = `-- name: ListUserOwnRepo :many
SELECT
   r.repo_id, r.user_id, r.git_protocol, r.git_host, r.git_username, r.git_repo, r.git_access_token, r.repo_name, r.repo_description, r.sync_token, r.visibility_level, r.commit_id, r.config, r.home, r.theme_sidebar, r.theme_color, r.created_at, r.updated_at, r.branch, r.fts_repo_en, r.fts_repo_zh,
  (SELECT COUNT(*) FROM repo_relations WHERE repo_id = r.repo_id and relation_type = 'like') AS like_count,
  EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.relation_type = 'like' AND repo_relations.user_id = $3) AS is_liked
FROM
    repos r
JOIN
    users as u ON u.user_id=r.user_id
WHERE
    u.user_id = $4 AND (
      ($5::text='admin' AND $6::bool ) OR (
        u.blocked='false' AND (
          r.visibility_level = 'public'
          OR 
          (r.visibility_level = 'signed' AND $6::bool)
          OR
          (r.visibility_level = 'chosen' AND $6::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $3 AND repo_relations.relation_type = 'visi'))
          OR
          ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $3 AND $6::bool)
        )
      )
    )
ORDER BY r.created_at DESC
LIMIT $1
OFFSET $2
`

type ListUserOwnRepoParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	CurUserID int64  `json:"cur_user_id"`
	UserID    int64  `json:"user_id"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
}

type ListUserOwnRepoRow struct {
	RepoID          int64       `json:"repo_id"`
	UserID          int64       `json:"user_id"`
	GitProtocol     string      `json:"git_protocol"`
	GitHost         string      `json:"git_host"`
	GitUsername     string      `json:"git_username"`
	GitRepo         string      `json:"git_repo"`
	GitAccessToken  pgtype.Text `json:"git_access_token"`
	RepoName        string      `json:"repo_name"`
	RepoDescription string      `json:"repo_description"`
	SyncToken       pgtype.Text `json:"sync_token"`
	VisibilityLevel string      `json:"visibility_level"`
	CommitID        string      `json:"commit_id"`
	Config          string      `json:"config"`
	Home            string      `json:"home"`
	ThemeSidebar    string      `json:"theme_sidebar"`
	ThemeColor      string      `json:"theme_color"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Branch          string      `json:"branch"`
	FtsRepoEn       string      `json:"fts_repo_en"`
	FtsRepoZh       string      `json:"fts_repo_zh"`
	LikeCount       int64       `json:"like_count"`
	IsLiked         bool        `json:"is_liked"`
}

func (q *Queries) ListUserOwnRepo(ctx context.Context, arg ListUserOwnRepoParams) ([]ListUserOwnRepoRow, error) {
	rows, err := q.db.Query(ctx, listUserOwnRepo,
		arg.Limit,
		arg.Offset,
		arg.CurUserID,
		arg.UserID,
		arg.Role,
		arg.Signed,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserOwnRepoRow{}
	for rows.Next() {
		var i ListUserOwnRepoRow
		if err := rows.Scan(
			&i.RepoID,
			&i.UserID,
			&i.GitProtocol,
			&i.GitHost,
			&i.GitUsername,
			&i.GitRepo,
			&i.GitAccessToken,
			&i.RepoName,
			&i.RepoDescription,
			&i.SyncToken,
			&i.VisibilityLevel,
			&i.CommitID,
			&i.Config,
			&i.Home,
			&i.ThemeSidebar,
			&i.ThemeColor,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Branch,
			&i.FtsRepoEn,
			&i.FtsRepoZh,
			&i.LikeCount,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryRepo = `-- name: QueryRepo :many
select 
  r.repo_id, r.user_id, r.git_protocol, r.git_host, r.git_username, r.git_repo, r.git_access_token, r.repo_name, r.repo_description, r.sync_token, r.visibility_level, r.commit_id, r.config, r.home, r.theme_sidebar, r.theme_color, r.created_at, r.updated_at, r.branch, r.fts_repo_en, r.fts_repo_zh,
  u.username,
  ROUND(ts_rank(r.fts_repo_en, plainto_tsquery($3))) + ROUND(ts_rank(r.fts_repo_zh, plainto_tsquery($3))) as rank
FROM
    repos r
JOIN 
  users u ON u.user_id = r.user_id
where (r.fts_repo_en @@ plainto_tsquery($3) OR r.fts_repo_zh @@ plainto_tsquery($3))
  AND (
    ($4::text='admin' AND $5::bool ) OR (
      u.blocked='false' AND (
        r.visibility_level = 'public'
        OR 
        (r.visibility_level = 'signed' AND $5::bool)
        OR
        (r.visibility_level = 'chosen' AND $5::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $6 AND repo_relations.relation_type = 'visi'))
        OR
        ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $6 AND $5::bool)
      )
    )
  )
ORDER BY rank DESC
LIMIT $1
OFFSET $2
`

type QueryRepoParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	Query     string `json:"query"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
	CurUserID int64  `json:"cur_user_id"`
}

type QueryRepoRow struct {
	RepoID          int64       `json:"repo_id"`
	UserID          int64       `json:"user_id"`
	GitProtocol     string      `json:"git_protocol"`
	GitHost         string      `json:"git_host"`
	GitUsername     string      `json:"git_username"`
	GitRepo         string      `json:"git_repo"`
	GitAccessToken  pgtype.Text `json:"git_access_token"`
	RepoName        string      `json:"repo_name"`
	RepoDescription string      `json:"repo_description"`
	SyncToken       pgtype.Text `json:"sync_token"`
	VisibilityLevel string      `json:"visibility_level"`
	CommitID        string      `json:"commit_id"`
	Config          string      `json:"config"`
	Home            string      `json:"home"`
	ThemeSidebar    string      `json:"theme_sidebar"`
	ThemeColor      string      `json:"theme_color"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Branch          string      `json:"branch"`
	FtsRepoEn       string      `json:"fts_repo_en"`
	FtsRepoZh       string      `json:"fts_repo_zh"`
	Username        string      `json:"username"`
	Rank            int32       `json:"rank"`
}

func (q *Queries) QueryRepo(ctx context.Context, arg QueryRepoParams) ([]QueryRepoRow, error) {
	rows, err := q.db.Query(ctx, queryRepo,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.Role,
		arg.Signed,
		arg.CurUserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryRepoRow{}
	for rows.Next() {
		var i QueryRepoRow
		if err := rows.Scan(
			&i.RepoID,
			&i.UserID,
			&i.GitProtocol,
			&i.GitHost,
			&i.GitUsername,
			&i.GitRepo,
			&i.GitAccessToken,
			&i.RepoName,
			&i.RepoDescription,
			&i.SyncToken,
			&i.VisibilityLevel,
			&i.CommitID,
			&i.Config,
			&i.Home,
			&i.ThemeSidebar,
			&i.ThemeColor,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Branch,
			&i.FtsRepoEn,
			&i.FtsRepoZh,
			&i.Username,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryUserLikeRepo = `-- name: QueryUserLikeRepo :many
SELECT
  r.repo_id, r.user_id, r.git_protocol, r.git_host, r.git_username, r.git_repo, r.git_access_token, r.repo_name, r.repo_description, r.sync_token, r.visibility_level, r.commit_id, r.config, r.home, r.theme_sidebar, r.theme_color, r.created_at, r.updated_at, r.branch, r.fts_repo_en, r.fts_repo_zh,ur.username,
  ROUND(ts_rank(r.fts_repo_en, plainto_tsquery($3))) + ROUND(ts_rank(r.fts_repo_zh, plainto_tsquery($3))) as rank,
  (SELECT COUNT(*) FROM repo_relations WHERE repo_id = r.repo_id and relation_type = 'like') AS like_count,
    EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id  and repo_relations.relation_type = 'like' and repo_relations.user_id = $4 ) as is_liked
FROM
    repos r
JOIN repo_relations AS rr ON r.repo_id = rr.repo_id
JOIN
    users as ur ON ur.user_id=r.user_id
JOIN
    users as uq ON uq.user_id=rr.user_id
WHERE
    (r.fts_repo_en @@ plainto_tsquery($3) OR r.fts_repo_zh @@ plainto_tsquery($3)) AND uq.user_id = $5 AND rr.relation_type='like' AND ( 
      ($6::text='admin' AND $7::bool ) OR (
        uq.blocked = FALSE AND ur.blocked =FALSE AND 
        (
          (r.visibility_level = 'public' ) 
          OR
          (r.visibility_level = 'signed' AND $7::bool) 
          OR
          (r.visibility_level = 'chosen' AND $7::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $4 AND repo_relations.relation_type = 'visi'))
          OR
          ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $4 AND $7::bool)
        )
      )
    )
ORDER BY rank DESC
LIMIT $1
OFFSET $2
`

type QueryUserLikeRepoParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	Query     string `json:"query"`
	CurUserID int64  `json:"cur_user_id"`
	UserID    int64  `json:"user_id"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
}

type QueryUserLikeRepoRow struct {
	RepoID          int64       `json:"repo_id"`
	UserID          int64       `json:"user_id"`
	GitProtocol     string      `json:"git_protocol"`
	GitHost         string      `json:"git_host"`
	GitUsername     string      `json:"git_username"`
	GitRepo         string      `json:"git_repo"`
	GitAccessToken  pgtype.Text `json:"git_access_token"`
	RepoName        string      `json:"repo_name"`
	RepoDescription string      `json:"repo_description"`
	SyncToken       pgtype.Text `json:"sync_token"`
	VisibilityLevel string      `json:"visibility_level"`
	CommitID        string      `json:"commit_id"`
	Config          string      `json:"config"`
	Home            string      `json:"home"`
	ThemeSidebar    string      `json:"theme_sidebar"`
	ThemeColor      string      `json:"theme_color"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Branch          string      `json:"branch"`
	FtsRepoEn       string      `json:"fts_repo_en"`
	FtsRepoZh       string      `json:"fts_repo_zh"`
	Username        string      `json:"username"`
	Rank            int32       `json:"rank"`
	LikeCount       int64       `json:"like_count"`
	IsLiked         bool        `json:"is_liked"`
}

func (q *Queries) QueryUserLikeRepo(ctx context.Context, arg QueryUserLikeRepoParams) ([]QueryUserLikeRepoRow, error) {
	rows, err := q.db.Query(ctx, queryUserLikeRepo,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.CurUserID,
		arg.UserID,
		arg.Role,
		arg.Signed,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryUserLikeRepoRow{}
	for rows.Next() {
		var i QueryUserLikeRepoRow
		if err := rows.Scan(
			&i.RepoID,
			&i.UserID,
			&i.GitProtocol,
			&i.GitHost,
			&i.GitUsername,
			&i.GitRepo,
			&i.GitAccessToken,
			&i.RepoName,
			&i.RepoDescription,
			&i.SyncToken,
			&i.VisibilityLevel,
			&i.CommitID,
			&i.Config,
			&i.Home,
			&i.ThemeSidebar,
			&i.ThemeColor,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Branch,
			&i.FtsRepoEn,
			&i.FtsRepoZh,
			&i.Username,
			&i.Rank,
			&i.LikeCount,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryUserOwnRepo = `-- name: QueryUserOwnRepo :many
SELECT
  r.repo_id, r.user_id, r.git_protocol, r.git_host, r.git_username, r.git_repo, r.git_access_token, r.repo_name, r.repo_description, r.sync_token, r.visibility_level, r.commit_id, r.config, r.home, r.theme_sidebar, r.theme_color, r.created_at, r.updated_at, r.branch, r.fts_repo_en, r.fts_repo_zh,
  ROUND(ts_rank(r.fts_repo_en, plainto_tsquery($3))) + ROUND(ts_rank(r.fts_repo_zh, plainto_tsquery($3))) as rank,
  (SELECT COUNT(*) FROM repo_relations WHERE repo_id = r.repo_id and relation_type = 'like') AS like_count,
  EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id  and repo_relations.relation_type = 'like' and repo_relations.user_id = $4 ) as is_liked
FROM
    repos r
JOIN
    users as u ON u.user_id=r.user_id
WHERE
    (r.fts_repo_en @@ plainto_tsquery($3) OR r.fts_repo_zh @@ plainto_tsquery($3)) AND u.user_id = $5 AND (
      ($6::text='admin' AND $7::bool ) OR (
        u.blocked='false' AND (
          r.visibility_level = 'public'
          OR 
          (r.visibility_level = 'signed' AND $7::bool)
          OR
          (r.visibility_level = 'chosen' AND $7::bool AND EXISTS(SELECT 1 FROM repo_relations WHERE repo_relations.repo_id = r.repo_id AND repo_relations.user_id = $4 AND repo_relations.relation_type = 'visi'))
          OR
          ((r.visibility_level = 'private' OR r.visibility_level = 'chosen') AND r.user_id = $4 AND $7::bool)
        )
      )
    )
ORDER BY rank DESC
LIMIT $1
OFFSET $2
`

type QueryUserOwnRepoParams struct {
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
	Query     string `json:"query"`
	CurUserID int64  `json:"cur_user_id"`
	UserID    int64  `json:"user_id"`
	Role      string `json:"role"`
	Signed    bool   `json:"signed"`
}

type QueryUserOwnRepoRow struct {
	RepoID          int64       `json:"repo_id"`
	UserID          int64       `json:"user_id"`
	GitProtocol     string      `json:"git_protocol"`
	GitHost         string      `json:"git_host"`
	GitUsername     string      `json:"git_username"`
	GitRepo         string      `json:"git_repo"`
	GitAccessToken  pgtype.Text `json:"git_access_token"`
	RepoName        string      `json:"repo_name"`
	RepoDescription string      `json:"repo_description"`
	SyncToken       pgtype.Text `json:"sync_token"`
	VisibilityLevel string      `json:"visibility_level"`
	CommitID        string      `json:"commit_id"`
	Config          string      `json:"config"`
	Home            string      `json:"home"`
	ThemeSidebar    string      `json:"theme_sidebar"`
	ThemeColor      string      `json:"theme_color"`
	CreatedAt       time.Time   `json:"created_at"`
	UpdatedAt       time.Time   `json:"updated_at"`
	Branch          string      `json:"branch"`
	FtsRepoEn       string      `json:"fts_repo_en"`
	FtsRepoZh       string      `json:"fts_repo_zh"`
	Rank            int32       `json:"rank"`
	LikeCount       int64       `json:"like_count"`
	IsLiked         bool        `json:"is_liked"`
}

func (q *Queries) QueryUserOwnRepo(ctx context.Context, arg QueryUserOwnRepoParams) ([]QueryUserOwnRepoRow, error) {
	rows, err := q.db.Query(ctx, queryUserOwnRepo,
		arg.Limit,
		arg.Offset,
		arg.Query,
		arg.CurUserID,
		arg.UserID,
		arg.Role,
		arg.Signed,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QueryUserOwnRepoRow{}
	for rows.Next() {
		var i QueryUserOwnRepoRow
		if err := rows.Scan(
			&i.RepoID,
			&i.UserID,
			&i.GitProtocol,
			&i.GitHost,
			&i.GitUsername,
			&i.GitRepo,
			&i.GitAccessToken,
			&i.RepoName,
			&i.RepoDescription,
			&i.SyncToken,
			&i.VisibilityLevel,
			&i.CommitID,
			&i.Config,
			&i.Home,
			&i.ThemeSidebar,
			&i.ThemeColor,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Branch,
			&i.FtsRepoEn,
			&i.FtsRepoZh,
			&i.Rank,
			&i.LikeCount,
			&i.IsLiked,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRepoConfig = `-- name: UpdateRepoConfig :exec
UPDATE repos
SET config=$2,commit_id=$3,home=$4,updated_at=now()
WHERE repo_id = $1
`

type UpdateRepoConfigParams struct {
	RepoID   int64  `json:"repo_id"`
	Config   string `json:"config"`
	CommitID string `json:"commit_id"`
	Home     string `json:"home"`
}

func (q *Queries) UpdateRepoConfig(ctx context.Context, arg UpdateRepoConfigParams) error {
	_, err := q.db.Exec(ctx, updateRepoConfig,
		arg.RepoID,
		arg.Config,
		arg.CommitID,
		arg.Home,
	)
	return err
}

const updateRepoInfo = `-- name: UpdateRepoInfo :one
UPDATE repos
SET 
repo_name=COALESCE($1,repo_name),
repo_description=COALESCE($2,repo_description),
sync_token=COALESCE($3,sync_token),
visibility_level=COALESCE($4,visibility_level),
git_access_token=COALESCE($5,git_access_token),
theme_sidebar=COALESCE($6,theme_sidebar),
theme_color=COALESCE($7,theme_color)
WHERE repo_id = $8
RETURNING repo_id, user_id, git_protocol, git_host, git_username, git_repo, git_access_token, repo_name, repo_description, sync_token, visibility_level, commit_id, config, home, theme_sidebar, theme_color, created_at, updated_at, branch, fts_repo_en, fts_repo_zh
`

type UpdateRepoInfoParams struct {
	RepoName        pgtype.Text `json:"repo_name"`
	RepoDescription pgtype.Text `json:"repo_description"`
	SyncToken       pgtype.Text `json:"sync_token"`
	VisibilityLevel pgtype.Text `json:"visibility_level"`
	GitAccessToken  pgtype.Text `json:"git_access_token"`
	ThemeSidebar    pgtype.Text `json:"theme_sidebar"`
	ThemeColor      pgtype.Text `json:"theme_color"`
	RepoID          int64       `json:"repo_id"`
}

func (q *Queries) UpdateRepoInfo(ctx context.Context, arg UpdateRepoInfoParams) (Repo, error) {
	row := q.db.QueryRow(ctx, updateRepoInfo,
		arg.RepoName,
		arg.RepoDescription,
		arg.SyncToken,
		arg.VisibilityLevel,
		arg.GitAccessToken,
		arg.ThemeSidebar,
		arg.ThemeColor,
		arg.RepoID,
	)
	var i Repo
	err := row.Scan(
		&i.RepoID,
		&i.UserID,
		&i.GitProtocol,
		&i.GitHost,
		&i.GitUsername,
		&i.GitRepo,
		&i.GitAccessToken,
		&i.RepoName,
		&i.RepoDescription,
		&i.SyncToken,
		&i.VisibilityLevel,
		&i.CommitID,
		&i.Config,
		&i.Home,
		&i.ThemeSidebar,
		&i.ThemeColor,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Branch,
		&i.FtsRepoEn,
		&i.FtsRepoZh,
	)
	return i, err
}
